#!/usr/bin/env python3
"""
Unified PARA Notes Interface for Claude Code

A comprehensive slash command interface that integrates all PARA Method functionality
into a single, Claude Code-friendly command with JSON output and natural language support.
"""

import os
import re
import sys
import json
import argparse
import datetime
import subprocess
from pathlib import Path
from typing import Dict, List, Any, Optional, Union
from dataclasses import dataclass, asdict

# Import existing PARA tools
current_dir = Path(__file__).parent.absolute()
sys.path.insert(0, str(current_dir))

try:
    # Import from our existing modules
    from para_processor import ParaNoteProcessor, ParsedNote, ActionItem, ParaCategory
    from para_templates import ParaTemplateEngine
except ImportError:
    # Fallback: execute as subprocess if modules can't be imported
    subprocess_mode = True
else:
    subprocess_mode = False

@dataclass
class CommandResult:
    """Standardized result format for Claude Code integration"""
    success: bool
    command: str
    message: str
    data: Dict[str, Any] = None
    suggestions: List[str] = None
    error_details: str = None

class NotesCommandInterface:
    """Unified interface for all PARA Method note operations"""

    def __init__(self):
        if not subprocess_mode:
            self.processor = ParaNoteProcessor()
            self.template_engine = ParaTemplateEngine()
        else:
            self.processor = None
            self.template_engine = None

        # Natural language patterns for parameter extraction
        self.nl_patterns = {
            'attendees': [
                r'with\s+([^,\n]+(?:,\s*[^,\n]+)*)',
                r'attendees?\s*:?\s*([^,\n]+(?:,\s*[^,\n]+)*)',
                r'participants?\s*:?\s*([^,\n]+(?:,\s*[^,\n]+)*)'
            ],
            'topic': [
                r'about\s+"([^"]+)"',
                r'about\s+([^,\n]+)',
                r'topic\s*:?\s*"([^"]+)"',
                r'topic\s*:?\s*([^,\n]+)',
                r'regarding\s+([^,\n]+)',
                r'for\s+([^,\n]+)'
            ],
            'date': [
                r'on\s+(\d{4}-\d{2}-\d{2})',
                r'for\s+(\d{4}-\d{2}-\d{2})',
                r'date\s*:?\s*(\d{4}-\d{2}-\d{2})'
            ],
            'template': [
                r'using\s+(\w+)\s+template',
                r'template\s*:?\s*(\w+)',
                r'as\s+(?:a\s+)?(\w+)'
            ]
        }

    def extract_natural_language_params(self, text: str) -> Dict[str, str]:
        """Extract parameters from natural language text"""
        params = {}

        # Process in specific order to avoid overlaps
        # 1. Extract template first (most specific)
        for pattern in self.nl_patterns['template']:
            match = re.search(pattern, text, re.IGNORECASE)
            if match:
                value = match.group(1).strip()
                value = re.sub(r'^["\']|["\']$', '', value)
                params['template'] = value
                # Remove the template part to avoid interference with other patterns
                text = re.sub(pattern, '', text, flags=re.IGNORECASE)
                break

        # 2. Extract topic (before attendees to avoid overlap)
        for pattern in self.nl_patterns['topic']:
            match = re.search(pattern, text, re.IGNORECASE)
            if match:
                value = match.group(1).strip()
                value = re.sub(r'^["\']|["\']$', '', value)
                # Clean topic of attendee indicators
                value = re.sub(r'\s+with\s+.*$', '', value, flags=re.IGNORECASE)
                params['topic'] = value
                break

        # 3. Extract attendees (after removing template and cleaning topic)
        for pattern in self.nl_patterns['attendees']:
            match = re.search(pattern, text, re.IGNORECASE)
            if match:
                value = match.group(1).strip()
                value = re.sub(r'^["\']|["\']$', '', value)
                # Clean up template remnants and dates from attendees
                value = re.sub(r'\s+using\s+\w+\s+template.*$', '', value, flags=re.IGNORECASE)
                value = re.sub(r'\s+on\s+\d{4}-\d{2}-\d{2}.*$', '', value, flags=re.IGNORECASE)
                params['attendees'] = value
                break

        # 4. Extract date (least likely to interfere)
        for pattern in self.nl_patterns['date']:
            match = re.search(pattern, text, re.IGNORECASE)
            if match:
                value = match.group(1).strip()
                value = re.sub(r'^["\']|["\']$', '', value)
                params['date'] = value
                break

        return params

    def format_success_result(self, command: str, message: str, data: Dict[str, Any] = None,
                            suggestions: List[str] = None) -> CommandResult:
        """Format a successful command result"""
        return CommandResult(
            success=True,
            command=command,
            message=message,
            data=data or {},
            suggestions=suggestions or []
        )

    def format_error_result(self, command: str, message: str, error_details: str = None,
                          suggestions: List[str] = None) -> CommandResult:
        """Format an error command result"""
        return CommandResult(
            success=False,
            command=command,
            message=message,
            error_details=error_details,
            suggestions=suggestions or []
        )

    def cmd_capture(self, args) -> CommandResult:
        """Capture new notes using templates"""
        try:
            # Parse natural language if provided
            nl_params = {}
            if hasattr(args, 'natural') and args.natural:
                nl_params = self.extract_natural_language_params(' '.join(args.natural))

            # Determine template
            template = args.template or nl_params.get('template', 'quick-note')

            if not subprocess_mode and self.template_engine:
                # Use native method
                # Get template list for validation
                available_templates = self.template_engine.list_templates()
                all_templates = available_templates['built-in'] + available_templates['custom']

                if template not in all_templates:
                    return self.format_error_result(
                        'capture',
                        f"Template '{template}' not found",
                        suggestions=[f"Available templates: {', '.join(all_templates[:5])}"]
                    )

                # Prepare variables
                variables = {
                    'title': args.topic or nl_params.get('topic', 'New Note'),
                    'attendees': args.attendees or nl_params.get('attendees', ''),
                    'date': args.date or nl_params.get('date') or datetime.date.today().strftime('%Y-%m-%d')
                }

                # Add custom variables
                if args.var:
                    for var in args.var:
                        if '=' in var:
                            key, value = var.split('=', 1)
                            variables[key] = value

                # Create note
                output_path = self.template_engine.create_note(
                    template,
                    variables,
                    args.output
                )
            else:
                # Fallback to subprocess
                cmd = ['./para-templates.py', 'create', template]

                # Add variables as arguments
                title = args.topic or nl_params.get('topic', 'New Note')
                attendees = args.attendees or nl_params.get('attendees', '')
                date = args.date or nl_params.get('date') or datetime.date.today().strftime('%Y-%m-%d')

                cmd.extend(['--title', title])
                if attendees:
                    cmd.extend(['--attendees', attendees])

                if args.output:
                    cmd.extend(['--output', args.output])

                # Add date as a custom variable since para-templates.py doesn't have --date
                cmd.extend(['--var', f'date={date}'])

                # Add custom variables
                if args.var:
                    for var in args.var:
                        if '=' in var:
                            cmd.extend(['--var', var])

                result = subprocess.run(cmd, capture_output=True, text=True)

                if result.returncode != 0:
                    return self.format_error_result(
                        'capture',
                        f"Template creation failed: {result.stderr.strip()}",
                        result.stderr.strip()
                    )

                # Parse output to get the created file path
                output_lines = result.stdout.strip().split('\n')
                output_path = None
                for line in output_lines:
                    if 'Created note:' in line:
                        output_path = line.split('Created note:')[1].strip()
                        break

                if not output_path:
                    output_path = f"{template}-note.md"  # fallback

                variables = {'title': title, 'attendees': attendees, 'date': date}

            return self.format_success_result(
                'capture',
                f"Created note: {output_path}",
                {
                    'file_path': output_path,
                    'template': template,
                    'variables': variables
                },
                [f"Edit with: code {output_path}", f"Process with: /notes research --file {output_path}"]
            )

        except Exception as e:
            return self.format_error_result(
                'capture',
                f"Failed to create note: {str(e)}",
                str(e),
                ["Check template name and parameters", "Use /notes list-templates to see available templates"]
            )

    def cmd_process_inbox(self, args) -> CommandResult:
        """Process inbox notes with batch operations"""
        try:
            directory = args.directory or 'inbox'

            if not Path(directory).exists():
                return self.format_error_result(
                    'process-inbox',
                    f"Directory '{directory}' does not exist",
                    suggestions=["Create inbox directory first", "Use correct directory path"]
                )

            if not subprocess_mode and self.processor:
                # Use native method
                notes = self.processor.batch_process_notes(directory, args.pattern or '*.md')

                if not notes:
                    return self.format_success_result(
                        'process-inbox',
                        f"No notes found in {directory}",
                        {'notes_processed': 0},
                        [f"Add notes to {directory} directory", "Check file pattern"]
                    )

                # Calculate statistics
                total_words = sum(note.word_count for note in notes)
                total_actions = sum(len(note.action_items) for note in notes)
                completed_actions = sum(
                    sum(1 for item in note.action_items if item.completed)
                    for note in notes
                )

                # Category suggestions if auto-suggest enabled
                suggestions_data = {}
                if args.auto_suggest:
                    suggestions_data = {}
                    for note in notes:
                        if note.suggested_category != ParaCategory.INBOX:
                            suggestions_data[note.file_path] = note.suggested_category.value

                # Limit batch processing if specified
                processed_count = len(notes)
                if args.batch and args.batch < len(notes):
                    notes = notes[:args.batch]
                    processed_count = args.batch

                total_notes = len(notes)
            else:
                # Fallback to subprocess
                cmd = ['./para-processor.py', 'batch', directory, '--summary']
                if args.pattern:
                    cmd.extend(['--pattern', args.pattern])

                result = subprocess.run(cmd, capture_output=True, text=True)

                if result.returncode != 0:
                    return self.format_error_result(
                        'process-inbox',
                        f"Failed to process notes: {result.stderr.strip()}",
                        result.stderr.strip()
                    )

                # Parse subprocess output to extract metrics
                output = result.stdout.strip()

                # Default values
                processed_count = 0
                total_notes = 0
                total_words = 0
                total_actions = 0
                completed_actions = 0
                suggestions_data = {}

                # Parse the output
                for line in output.split('\n'):
                    if 'Processed' in line and 'notes' in line:
                        # Extract number from "üìä Processed 7 notes"
                        parts = line.split()
                        for part in parts:
                            if part.isdigit():
                                processed_count = int(part)
                                total_notes = processed_count
                                break
                    elif 'Total words:' in line:
                        # Extract from "üìù Total words: 817"
                        parts = line.split(':')
                        if len(parts) > 1:
                            try:
                                total_words = int(parts[1].strip())
                            except ValueError:
                                pass
                    elif 'Action items:' in line:
                        # Extract from "‚úÖ Action items: 0/50 completed"
                        parts = line.split(':')
                        if len(parts) > 1:
                            action_part = parts[1].strip()
                            if '/' in action_part:
                                try:
                                    completed_str, total_str = action_part.split('/')
                                    completed_actions = int(completed_str.strip())
                                    total_actions = int(total_str.split()[0])  # Remove 'completed' word
                                except ValueError:
                                    pass

                # Apply batch limit if specified
                if args.batch and args.batch < processed_count:
                    processed_count = args.batch

                if processed_count == 0:
                    return self.format_success_result(
                        'process-inbox',
                        f"No notes found in {directory}",
                        {'notes_processed': 0},
                        [f"Add notes to {directory} directory", "Check file pattern"]
                    )

            return self.format_success_result(
                'process-inbox',
                f"Processed {processed_count} notes from {directory}",
                {
                    'notes_processed': processed_count,
                    'total_notes': total_notes,
                    'total_words': total_words,
                    'action_items': {
                        'total': total_actions,
                        'completed': completed_actions,
                        'pending': total_actions - completed_actions
                    },
                    'suggestions': suggestions_data if args.auto_suggest else {}
                },
                [
                    f"Review suggestions with: /notes review --directory {directory}",
                    f"Find action items with: /notes follow-up --directory {directory}"
                ]
            )

        except Exception as e:
            return self.format_error_result(
                'process-inbox',
                f"Failed to process inbox: {str(e)}",
                str(e),
                ["Check directory permissions", "Verify note file format"]
            )

    def cmd_research(self, args) -> CommandResult:
        """Research and analyze existing notes"""
        try:
            if args.file:
                # Single file analysis
                note = self.processor.parse_note(args.file, validate=not args.graceful)

                # Extract research-relevant information
                research_data = {
                    'file_path': note.file_path,
                    'word_count': note.word_count,
                    'read_time': note.estimated_read_time,
                    'category': note.suggested_category.value,
                    'tags': note.tags,
                    'key_dates': note.dates,
                    'action_items': len(note.action_items),
                    'attendees': note.attendees
                }

                # Topic expansion if requested
                expanded_topics = []
                if args.expand_topics:
                    # Find related topics from tags and content
                    expanded_topics = self._find_related_topics(note)

                return self.format_success_result(
                    'research',
                    f"Analyzed note: {Path(args.file).name}",
                    {
                        'analysis': research_data,
                        'expanded_topics': expanded_topics
                    },
                    [
                        f"Open file: code {args.file}",
                        "Find related notes: /notes find --query \"" + ' '.join(note.tags[:3]) + "\""
                    ]
                )

            else:
                return self.format_error_result(
                    'research',
                    "No file specified for research",
                    suggestions=["Use --file parameter to specify note to analyze"]
                )

        except Exception as e:
            return self.format_error_result(
                'research',
                f"Research failed: {str(e)}",
                str(e),
                ["Check file path exists", "Use --graceful for malformed notes"]
            )

    def cmd_find(self, args) -> CommandResult:
        """Find notes based on query, date range, or other criteria"""
        try:
            directory = args.directory or '.'
            results = []

            # Get all notes in directory
            notes = self.processor.batch_process_notes(directory, '*.md')

            # Apply query filter
            if args.query:
                query_terms = args.query.lower().split()
                filtered_notes = []

                for note in notes:
                    # Search in content, tags, and frontmatter
                    search_text = (
                        note.content.lower() + ' ' +
                        ' '.join(note.tags).lower() + ' ' +
                        json.dumps(note.frontmatter).lower()
                    )

                    if any(term in search_text for term in query_terms):
                        # Calculate relevance score
                        score = sum(search_text.count(term) for term in query_terms)
                        filtered_notes.append((note, score))

                # Sort by relevance
                filtered_notes.sort(key=lambda x: x[1], reverse=True)
                notes = [note for note, score in filtered_notes]

            # Apply date range filter
            if args.date_range:
                notes = self._filter_by_date_range(notes, args.date_range)

            # Limit results
            limit = args.limit or 10
            results = notes[:limit]

            # Format results
            result_data = []
            for note in results:
                result_data.append({
                    'file': str(Path(note.file_path).name),
                    'path': note.file_path,
                    'words': note.word_count,
                    'tags': note.tags,
                    'category': note.suggested_category.value,
                    'action_items': len([item for item in note.action_items if not item.completed])
                })

            return self.format_success_result(
                'find',
                f"Found {len(results)} matching notes",
                {
                    'query': args.query or 'all',
                    'total_matches': len(notes),
                    'results_shown': len(results),
                    'results': result_data
                },
                [f"Open result: code {results[0].file_path}" if results else "Refine search query"]
            )

        except Exception as e:
            return self.format_error_result(
                'find',
                f"Search failed: {str(e)}",
                str(e),
                ["Check directory exists", "Verify search query format"]
            )

    def cmd_follow_up(self, args) -> CommandResult:
        """Manage action items and follow-ups"""
        try:
            directory = args.directory or '.'

            if args.status == 'overdue':
                # Find orphaned/overdue action items
                orphaned_items = self.processor.find_orphaned_action_items(directory)

                action_data = []
                for file_path, action_item in orphaned_items:
                    action_data.append({
                        'file': str(Path(file_path).name),
                        'path': file_path,
                        'text': action_item.text,
                        'line': action_item.line_number,
                        'assignee': action_item.assignee,
                        'due_date': action_item.due_date,
                        'priority': action_item.priority
                    })

                return self.format_success_result(
                    'follow-up',
                    f"Found {len(action_data)} overdue/orphaned action items",
                    {
                        'status': 'overdue',
                        'total_items': len(action_data),
                        'items': action_data[:10]  # Limit display
                    },
                    [
                        f"Review item: code {action_data[0]['path']}:{action_data[0]['line']}" if action_data else None,
                        "Update due dates and assignees"
                    ]
                )

            else:
                # General action item summary
                notes = self.processor.batch_process_notes(directory, '*.md')
                all_actions = []

                for note in notes:
                    for action in note.action_items:
                        if args.assignee and args.assignee.lower() not in (action.assignee or '').lower():
                            continue

                        all_actions.append({
                            'file': str(Path(note.file_path).name),
                            'path': note.file_path,
                            'text': action.text,
                            'completed': action.completed,
                            'assignee': action.assignee,
                            'due_date': action.due_date,
                            'priority': action.priority
                        })

                incomplete_count = len([a for a in all_actions if not a['completed']])

                return self.format_success_result(
                    'follow-up',
                    f"Found {len(all_actions)} action items ({incomplete_count} incomplete)",
                    {
                        'total_items': len(all_actions),
                        'incomplete': incomplete_count,
                        'completed': len(all_actions) - incomplete_count,
                        'items': all_actions[:10]
                    },
                    [
                        "Focus on incomplete items",
                        "Set due dates and assignees for better tracking"
                    ]
                )

        except Exception as e:
            return self.format_error_result(
                'follow-up',
                f"Follow-up failed: {str(e)}",
                str(e),
                ["Check directory permissions", "Verify action item format"]
            )

    def cmd_prep(self, args) -> CommandResult:
        """Prepare for meetings and events"""
        try:
            # Prepare meeting with specified topic and attendees
            topic = args.topic or 'Meeting Preparation'
            attendees = args.attendees or ''

            # Create meeting preparation note
            variables = {
                'title': f"Prep: {topic}",
                'topic': topic,
                'attendees': attendees,
                'date': datetime.date.today().strftime('%Y-%m-%d')
            }

            # Use meeting template for preparation
            output_path = self.template_engine.create_note('meeting', variables, args.output)

            # Find related notes based on topic
            related_notes = []
            if topic and topic != 'Meeting Preparation':
                try:
                    # Simple search for related content
                    notes = self.processor.batch_process_notes('.', '*.md')
                    topic_lower = topic.lower()

                    for note in notes:
                        if topic_lower in note.content.lower() or topic_lower in ' '.join(note.tags).lower():
                            related_notes.append({
                                'file': str(Path(note.file_path).name),
                                'path': note.file_path,
                                'relevance': 'topic_match'
                            })

                    related_notes = related_notes[:5]  # Limit to 5 most relevant
                except:
                    pass  # Continue without related notes if search fails

            return self.format_success_result(
                'prep',
                f"Created meeting prep note: {Path(output_path).name}",
                {
                    'prep_file': output_path,
                    'topic': topic,
                    'attendees': attendees.split(',') if attendees else [],
                    'related_notes': related_notes
                },
                [
                    f"Edit prep notes: code {output_path}",
                    "Review related notes before meeting"
                ]
            )

        except Exception as e:
            return self.format_error_result(
                'prep',
                f"Meeting prep failed: {str(e)}",
                str(e),
                ["Check template availability", "Verify topic and attendees format"]
            )

    def cmd_list_templates(self, args) -> CommandResult:
        """List available note templates"""
        try:
            if not subprocess_mode and self.template_engine:
                # Use native method
                templates = self.template_engine.list_templates()

                template_data = {}
                for category, template_list in templates.items():
                    template_data[category] = []
                    for template in template_list:
                        info = self.template_engine.get_template_info(template)
                        template_data[category].append({
                            'name': template,
                            'description': info.get('description', 'No description') if info else 'No description'
                        })

                total_templates = sum(len(tlist) for tlist in templates.values())
            else:
                # Fallback to subprocess
                result = subprocess.run(['./para-templates.py', 'list'],
                                      capture_output=True, text=True, check=True)
                output = result.stdout.strip()

                # Parse the output to extract template information
                template_data = {'Built-in': [], 'Custom': []}
                current_category = None
                total_templates = 0

                for line in output.split('\n'):
                    line_stripped = line.strip()
                    if line_stripped == 'Built-in:':
                        current_category = 'Built-in'
                    elif line_stripped == 'Custom:':
                        current_category = 'Custom'
                    elif line and current_category and line.startswith('  ') and ' - ' in line:
                        # Parse template line: "  template_name - description"
                        parts = line.strip().split(' - ', 1)
                        if len(parts) == 2:
                            name = parts[0].strip()
                            description = parts[1].strip()
                            template_data[current_category].append({
                                'name': name,
                                'description': description
                            })
                            total_templates += 1

            return self.format_success_result(
                'list-templates',
                f"Found {total_templates} available templates",
                {
                    'templates': template_data,
                    'total': total_templates
                },
                [
                    "Create note: /notes capture --template meeting --topic 'Your Topic'",
                    "View template details: /notes template-info --name meeting"
                ]
            )

        except Exception as e:
            return self.format_error_result(
                'list-templates',
                f"Failed to list templates: {str(e)}",
                str(e)
            )

    def _find_related_topics(self, note: 'ParsedNote') -> List[str]:
        """Find topics related to the current note"""
        topics = []

        # Extract topics from tags
        topics.extend(note.tags)

        # Extract topics from common patterns in content
        topic_patterns = [
            r'(?:topic|subject|about|regarding|concerning):\s*([^\n]+)',
            r'#\s*([A-Za-z][A-Za-z0-9\s-]+)',  # Headings
        ]

        for pattern in topic_patterns:
            matches = re.findall(pattern, note.content, re.IGNORECASE)
            topics.extend([m.strip() for m in matches if len(m.strip()) > 2])

        # Remove duplicates and return unique topics
        return list(set(topics))[:10]  # Limit to 10 topics

    def _filter_by_date_range(self, notes: List['ParsedNote'], date_range: str) -> List['ParsedNote']:
        """Filter notes by date range"""
        if date_range == 'today':
            target_date = datetime.date.today().strftime('%Y-%m-%d')
        elif date_range == 'yesterday':
            target_date = (datetime.date.today() - datetime.timedelta(days=1)).strftime('%Y-%m-%d')
        elif date_range == 'last-week':
            target_date = (datetime.date.today() - datetime.timedelta(days=7)).strftime('%Y-%m-%d')
        elif date_range == 'last-month':
            target_date = (datetime.date.today() - datetime.timedelta(days=30)).strftime('%Y-%m-%d')
        else:
            return notes  # Unknown date range, return all

        filtered = []
        for note in notes:
            # Check if any date in the note matches our criteria
            if any(date >= target_date for date in note.dates):
                filtered.append(note)
            # Also check file modification time as fallback
            elif Path(note.file_path).stat().st_mtime > (datetime.datetime.now() - datetime.timedelta(days=7)).timestamp():
                filtered.append(note)

        return filtered

def main():
    """Main CLI interface"""
    parser = argparse.ArgumentParser(
        description="Unified PARA Notes Interface for Claude Code",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  /notes capture --template meeting --topic "Q4 Planning" --attendees "john,sarah"
  /notes process-inbox --auto-suggest --batch 5
  /notes research --file "project-kickoff.md" --expand-topics
  /notes find --query "budget concerns" --date-range last-month
  /notes follow-up --status overdue
  /notes prep --topic "budget review" --attendees "cfo,manager"

Natural language support:
  /notes capture about "sprint planning" with john,sarah using meeting template
  /notes find about "api design" from last-week
        """)

    # Add JSON output option
    parser.add_argument('--json', action='store_true', help='Output results as JSON')
    parser.add_argument('--format', choices=['json', 'text'], default='json', help='Output format (default: json)')

    subparsers = parser.add_subparsers(dest='command', help='Available commands')

    # Capture command
    capture_parser = subparsers.add_parser('capture', help='Create new notes from templates')
    capture_parser.add_argument('--template', help='Template to use')
    capture_parser.add_argument('--topic', help='Note topic/title')
    capture_parser.add_argument('--attendees', help='Comma-separated attendees list')
    capture_parser.add_argument('--date', help='Date (YYYY-MM-DD)')
    capture_parser.add_argument('--output', '-o', help='Output file path')
    capture_parser.add_argument('--var', action='append', help='Custom variable (key=value)')
    capture_parser.add_argument('natural', nargs='*', help='Natural language input')

    # Process inbox command
    process_parser = subparsers.add_parser('process-inbox', help='Process inbox notes')
    process_parser.add_argument('--directory', default='inbox', help='Directory to process')
    process_parser.add_argument('--pattern', default='*.md', help='File pattern')
    process_parser.add_argument('--auto-suggest', action='store_true', help='Auto-suggest PARA categories')
    process_parser.add_argument('--batch', type=int, help='Limit number of notes to process')

    # Research command
    research_parser = subparsers.add_parser('research', help='Research and analyze notes')
    research_parser.add_argument('--file', help='Note file to analyze')
    research_parser.add_argument('--expand-topics', action='store_true', help='Find related topics')
    research_parser.add_argument('--graceful', action='store_true', help='Handle malformed notes gracefully')

    # Find command
    find_parser = subparsers.add_parser('find', help='Search for notes')
    find_parser.add_argument('--query', help='Search query')
    find_parser.add_argument('--date-range', choices=['today', 'yesterday', 'last-week', 'last-month'], help='Date range filter')
    find_parser.add_argument('--directory', default='.', help='Directory to search')
    find_parser.add_argument('--limit', type=int, default=10, help='Maximum results')

    # Follow-up command
    followup_parser = subparsers.add_parser('follow-up', help='Manage action items')
    followup_parser.add_argument('--status', choices=['all', 'overdue', 'pending', 'completed'], default='all')
    followup_parser.add_argument('--assignee', help='Filter by assignee')
    followup_parser.add_argument('--directory', default='.', help='Directory to search')

    # Prep command
    prep_parser = subparsers.add_parser('prep', help='Prepare for meetings')
    prep_parser.add_argument('--topic', help='Meeting topic')
    prep_parser.add_argument('--attendees', help='Comma-separated attendees')
    prep_parser.add_argument('--output', help='Output file path')

    # List templates command
    list_parser = subparsers.add_parser('list-templates', help='List available templates')

    # Parse arguments
    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return

    # Create interface and execute command
    interface = NotesCommandInterface()

    try:
        # Route to appropriate command handler
        command_methods = {
            'capture': interface.cmd_capture,
            'process-inbox': interface.cmd_process_inbox,
            'research': interface.cmd_research,
            'find': interface.cmd_find,
            'follow-up': interface.cmd_follow_up,
            'prep': interface.cmd_prep,
            'list-templates': interface.cmd_list_templates,
        }

        if args.command in command_methods:
            result = command_methods[args.command](args)
        else:
            result = interface.format_error_result(
                args.command,
                f"Unknown command: {args.command}",
                suggestions=list(command_methods.keys())
            )

        # Output result
        if args.format == 'json' or args.json:
            print(json.dumps(asdict(result), indent=2, default=str))
        else:
            # Text format for debugging
            if result.success:
                print(f"‚úÖ {result.message}")
                if result.data:
                    for key, value in result.data.items():
                        print(f"   {key}: {value}")
            else:
                print(f"‚ùå {result.message}")
                if result.error_details:
                    print(f"   Error: {result.error_details}")

            if result.suggestions:
                print("\nSuggestions:")
                for suggestion in result.suggestions:
                    if suggestion:
                        print(f"   ‚Ä¢ {suggestion}")

    except Exception as e:
        error_result = interface.format_error_result(
            args.command or 'unknown',
            f"Unexpected error: {str(e)}",
            str(e)
        )

        if args.format == 'json' or args.json:
            print(json.dumps(asdict(error_result), indent=2, default=str))
        else:
            print(f"‚ùå {error_result.message}")
            print(f"   Error: {error_result.error_details}")

if __name__ == '__main__':
    main()